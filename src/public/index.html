<!DOCTYPE html>
<html style="background-color: #121212; color: white;">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>WebXR Pose Data</title>
    <style>
      body, html {
        margin: 0;
        padding: 0;
        background-color: #121212;
        color: white;
        font-family: 'Segoe UI', Roboto, Arial, sans-serif;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        overscroll-behavior: none; /* Prevent pull-to-refresh on mobile */
      }

      /* iOS-specific fixes */
      @supports (-webkit-touch-callout: none) {
        body, html {
          height: -webkit-fill-available;
          touch-action: manipulation; /* Disable double-tap zoom */
        }
        
        button, select, input {
          -webkit-appearance: none;
          -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
          font-size: 16px; /* Prevent iOS zoom on input focus */
        }
        
        video::-webkit-media-controls {
          display: none !important;
        }
        
        /* Make buttons more tappable on iOS */
        .sensor-select label {
          padding: 1.1rem 1.2rem;
        }
        
        #xr-button {
          padding: 1rem;
        }
      }

      .container {
        background: rgba(35, 35, 40, 0.95);
        padding: 1.8rem;
        border-radius: 12px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
        max-width: 650px;
        width: 95%;
        margin: 10px;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .title {
        text-align: center;
        margin-bottom: 1.5rem;
        font-size: 24px;
        font-weight: 600;
        background: linear-gradient(90deg, #64B5F6, #E040FB);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: 0.5px;
      }

      .sensor-section {
        margin-bottom: 15px;
      }

      .section-title {
        font-size: 16px;
        font-weight: 500;
        margin-bottom: 8px;
        color: #90CAF9;
      }

      .sensor-select {
        position: static;
        background: none;
        padding: 0;
      }

      .sensor-select label {
        display: flex;
        align-items: center;
        padding: 1rem 1.2rem;
        margin: 0.6rem 0;
        background: rgba(50, 50, 60, 0.6);
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        justify-content: space-between;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .sensor-select label:hover {
        background: rgba(70, 70, 80, 0.7);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }

      .sensor-checkbox-container {
        display: flex;
        align-items: center;
      }

      .sensor-select input[type="checkbox"] {
        appearance: none;
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        background: rgba(30, 30, 35, 0.9);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        margin-right: 12px;
        position: relative;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .sensor-select input[type="checkbox"]:checked {
        background: #4CAF50;
        border-color: #4CAF50;
      }

      .sensor-select input[type="checkbox"]:checked::after {
        content: 'âœ“';
        position: absolute;
        color: white;
        font-size: 14px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      .sensor-name {
        font-size: 15px;
        font-weight: 500;
      }

      #xr-button {
        width: 100%;
        padding: 0.9rem;
        font-size: 18px;
        margin-top: 1.5rem;
        background: linear-gradient(90deg, #4CAF50, #2E7D32);
        border: none;
        border-radius: 8px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 600;
        letter-spacing: 0.5px;
        box-shadow: 0 4px 10px rgba(46, 125, 50, 0.4);
      }

      #xr-button:hover {
        background: linear-gradient(90deg, #66BB6A, #388E3C);
        transform: translateY(-2px);
        box-shadow: 0 6px 15px rgba(46, 125, 50, 0.5);
      }

      #xr-button:active {
        transform: translateY(1px);
      }

      #xr-button:disabled {
        background: linear-gradient(90deg, #9E9E9E, #757575);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
        opacity: 0.7;
      }

      /* Connection status indicator styles */
      .connection-status {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-left: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
      }
      
      .connected { 
        background: #43A047; 
        box-shadow: 0 0 6px rgba(67, 160, 71, 0.6);
      }
      
      .disconnected { 
        background: #E53935; 
        box-shadow: 0 0 6px rgba(229, 57, 53, 0.6);
      }
      
      .connecting { 
        background: #FB8C00;
        box-shadow: 0 0 6px rgba(251, 140, 0, 0.6);
        animation: pulse 1.5s infinite;
      }
      
      @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
      }

      #pose {
        display: none;
        background: rgba(35, 35, 40, 0.8);
        padding: 12px;
        border-radius: 8px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.4;
        margin-top: 15px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        max-width: 600px;
        width: 90%;
        text-align: left;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        overflow-x: auto;
      }

      /* Show them only when session is active */
      body.session-active #pose,
      body.session-active #transcription-log {
        display: block;
      }

      #overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #121212;
        z-index: -1;
      }
      
      #transcription-log {
        position: fixed;
        bottom: 15px;
        left: 15px;
        right: 15px;
        max-height: 120px;
        overflow-y: auto;
        background: rgba(20, 20, 25, 0.85);
        padding: 12px;
        border-radius: 10px;
        font-size: 14px;
        line-height: 1.4;
        z-index: 1000;
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        display: none;
      }
      
      .log-entry {
        margin: 6px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        padding-bottom: 6px;
      }
      
      .timestamp {
        color: #90CAF9;
        font-size: 0.8em;
        margin-right: 8px;
        font-weight: 500;
      }
      
      #wav-status {
        padding: 8px 12px;
        margin: 8px 0;
        font-size: 0.9em;
        color: #BBDEFB;
        background: rgba(50, 50, 60, 0.4);
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }
      
      /* Camera select dropdown styling - modified to be inline */
      .camera-select-container {
        margin-top: 12px;
        padding: 10px 12px;
        background: rgba(50, 50, 60, 0.4);
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
      }
      
      #camera-dropdown {
        flex: 1;
        min-width: 160px;
        padding: 8px;
        background: rgba(35, 35, 40, 0.9);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 5px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-left: 10px;
      }
      
      #camera-dropdown:hover {
        background: rgba(45, 45, 50, 0.9);
        border-color: rgba(255, 255, 255, 0.3);
      }
      
      #camera-dropdown:focus {
        outline: none;
        border-color: #90CAF9;
        box-shadow: 0 0 0 2px rgba(144, 202, 249, 0.3);
      }
      
      #camera-dropdown option {
        background: rgba(35, 35, 40, 0.9);
        color: white;
        padding: 8px;
      }
      
      .camera-label {
        font-weight: 500;
        color: #BBDEFB;
        font-size: 14px;
      }

      /* Media query for small screens to stack the dropdown */
      @media (max-width: 480px) {
        .camera-select-container {
          flex-direction: column;
          align-items: flex-start;
        }
        
        #camera-dropdown {
          margin-left: 0;
          margin-top: 8px;
          width: 100%;
        }
        
        .title {
          font-size: 20px;
          margin-bottom: 1rem;
        }
        
        .container {
          padding: 1.2rem;
          margin: 8px;
          width: 99%;
        }
        
        #xr-button {
          padding: 0.9rem;
          font-size: 16px;
        }
        
        .sensor-select label {
          padding: 0.8rem 0.9rem;
        }
        
        .section-title {
          font-size: 15px;
        }
      }
      
      /* Additional responsive adjustments for very small screens */
      @media (max-width: 360px) {
        .container {
          padding: 1rem;
          width: 99%;
        }
        
        .title {
          font-size: 18px;
        }
        
        .sensor-name {
          font-size: 14px;
        }
        
        .sensor-select label {
          padding: 0.7rem 0.8rem;
        }
        
        .sensor-select input[type="checkbox"] {
          width: 16px;
          height: 16px;
          margin-right: 8px;
        }
        
        .camera-label {
          font-size: 13px;
        }
        
        #camera-dropdown {
          font-size: 13px;
          padding: 6px;
        }
      }
    </style>
    <!-- Load camera script separately from other scripts -->
    <script src="camera.js"></script>
    <script src="speechRecognition.js"></script>
    <!-- Load audio player for WAV playback -->
    <script src="audioPlayer.js"></script>
    <!-- Load TTS script upfront -->
    <script src="textToSpeech.js"></script>
  </head>
  <body>
    <div id="overlay"></div>
    
    <div class="container">
      <div class="title">Sensor Interface</div>
      
      <div class="sensor-section">
        <div class="section-title">Input Sensors</div>
        <div class="sensor-select">
          <label>
            <div class="sensor-checkbox-container">
              <input type="checkbox" id="camera-select" checked>
              <span class="sensor-name">Camera Stream</span>
            </div>
            <div class="connection-status" id="camera-status"></div>
          </label>
          
          <!-- Camera selection dropdown integrated directly into camera option -->
          <div class="camera-select-container" id="camera-select-container">
            <label class="camera-label" for="camera-dropdown">Select Camera:</label>
            <select id="camera-dropdown"></select>
          </div>
          
          <label>
            <div class="sensor-checkbox-container">
              <input type="checkbox" id="pose-select" checked>
              <span class="sensor-name">3D Position</span>
            </div>
            <div class="connection-status" id="pose-status"></div>
          </label>
          
          <label>
            <div class="sensor-checkbox-container">
              <input type="checkbox" id="microphone-select" checked>
              <span class="sensor-name">Microphone</span>
            </div>
            <div class="connection-status" id="microphone-status"></div>
          </label>
        </div>
      </div>
      
      <div class="sensor-section">
        <div class="section-title">Output</div>
        <div class="sensor-select">
          <label>
            <div class="sensor-checkbox-container">
              <input type="checkbox" id="audio-select" checked>
              <span class="sensor-name">Audio</span>
            </div>
            <div class="connection-status" id="audio-status"></div>
          </label>
        </div>
      </div>
      
      <button id="xr-button" disabled>XR not found</button>
    </div>

    <div id="pose">Pose data will appear here.</div>
    <div id="transcription-log"></div>

    <script>
      // Add a function to populate camera dropdown
      async function populateCameraDropdown() {
        try {
          const dropdown = document.getElementById('camera-dropdown');
          if (!dropdown) return;
          
          // Clear existing options
          dropdown.innerHTML = '';
          
          // Get available cameras
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(device => device.kind === 'videoinput');
          
          if (videoDevices.length === 0) {
            const option = document.createElement('option');
            option.text = 'No cameras found';
            dropdown.add(option);
            return;
          }
          
          // Add options for each camera
          videoDevices.forEach((device, index) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${index + 1}`;
            dropdown.add(option);
          });
          
          // Add event listener to handle camera change
          dropdown.addEventListener('change', (e) => {
            if (cameraManager && typeof cameraManager.switchCamera === 'function') {
              cameraManager.switchCamera(e.target.value);
            }
          });
          
          // Show container if we have cameras
          document.getElementById('camera-select-container').style.display = videoDevices.length > 0 ? 'flex' : 'none';
        } catch (error) {
          console.error('Error populating camera dropdown:', error);
        }
      }
      
      // Function to dynamically load audio script based on config
      async function loadAudioScript() {
        try {
          const response = await fetch('/api/config');
          const config = await response.json();
          return config.audio || { mode: 'tts', enabled: true };
        } catch (error) {
          console.error('Error loading audio configuration:', error);
          return { mode: 'tts', enabled: true };
        }
      }
      
      // Helper function to dynamically load scripts
      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = src;
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }
      
      // Initialize when DOM is ready
      document.addEventListener('DOMContentLoaded', () => {
        loadAudioScript().then(audioConfig => {
          if (window.TextToSpeech && (!window.tts || !window.tts.isReady)) {
            window.tts = new TextToSpeech();
          }
        });
        populateCameraDropdown();
      });
      
      let xrSession = null;
      let xrRefSpace = null;
      const xrButton = document.getElementById('xr-button');
      const poseDiv = document.getElementById('pose');
      let poseWs = null;  // Separate WebSocket for pose data
      let cameraWs = null;  // Separate WebSocket for camera data
      let ttsWs = null;  // Reference to TTS WebSocket
      let isSessionActive = false;
      const cameraManager = new CameraManager();
      const speechRecognitionManager = new SpeechRecognitionManager();
      let microphoneWs = null;
      let cameraInterval = null;
      let cameraSendingActive = false;

      // Add sensor selection states
      let enabledSensors = {
        camera: true,
        pose: true,
        microphone: true,
        audio: true
      };

      // Add checkbox event listeners
      document.getElementById('camera-select').addEventListener('change', (e) => {
        enabledSensors.camera = e.target.checked;
        document.getElementById('camera-select-container').style.display = e.target.checked ? 'flex' : 'none';
        if (!e.target.checked && cameraInterval) {
          stopCameraSending();
        } else if (e.target.checked && isSessionActive) {
          startCameraSending();
        }
      });

      document.getElementById('pose-select').addEventListener('change', (e) => {
        enabledSensors.pose = e.target.checked;
        poseDiv.style.display = e.target.checked ? 'block' : 'none';
        checkSupported(); // Recheck AR support when pose tracking is toggled
      });

      document.getElementById('microphone-select').addEventListener('change', (e) => {
        enabledSensors.microphone = e.target.checked;
        document.getElementById('transcription-log').style.display = e.target.checked ? 'block' : 'none';
        if (!e.target.checked) {
          speechRecognitionManager.stopSpeechRecognition();
        } else if (isSessionActive) {
          connectWebSockets();
        }
      });

      // Add Audio checkbox listener - this refers to output audio
      document.getElementById('audio-select').addEventListener('change', async (e) => {
        enabledSensors.audio = e.target.checked;
        
        if (!e.target.checked) {
          if (window.tts) {
            window.tts.disconnectWebSocket();
          }
          updateConnectionStatus('audio', 'disconnected');
        } else if (e.target.checked && isSessionActive) {
          updateConnectionStatus('audio', 'connecting');
          
          if (!window.tts) {
            window.tts = new TextToSpeech();
          }
          
          try {
            await window.tts.connectWebSocket();
            updateConnectionStatus('audio', 'connected');
          } catch (error) {
            console.error('Failed to connect TTS WebSocket:', error);
            updateConnectionStatus('audio', 'disconnected');
          }
        }
      });

      // Modify checkSupported to only check if position tracking is selected
      function checkSupported() {
        if (!enabledSensors.pose) {
          xrButton.disabled = false;
          xrButton.textContent = 'Start';
          return;
        }

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then(supported => {
            xrButton.disabled = !supported;
            xrButton.textContent = supported ? 'Start' : 'XR not found';
          });
        } else {
          xrButton.disabled = true;
          xrButton.textContent = 'XR not supported';
        }
      }
      checkSupported();
      navigator.xr && navigator.xr.addEventListener('devicechange', checkSupported);

      // Update the button click handler
      xrButton.addEventListener('click', () => {
        if (!isSessionActive) {
          startSession();
        } else {
          if (xrSession) {
            xrSession.end();
          } else {
            // For non-AR sessions, call onSessionEnded directly
            onSessionEnded();
          }
        }
      });

      // Function to update connection status indicators
      function updateConnectionStatus(type, status) {
        const statusEl = document.getElementById(`${type}-status`);
        if (statusEl) {
          statusEl.className = `connection-status ${status}`;
        }
        
        // Log status changes to the console
        if (status === 'disconnected') {
          console.log(`${type.charAt(0).toUpperCase() + type.slice(1)} sensor disconnected`);
        } else if (status === 'connected') {
          console.log(`${type.charAt(0).toUpperCase() + type.slice(1)} sensor connected`);
        } else if (status === 'connecting') {
          console.log(`${type.charAt(0).toUpperCase() + type.slice(1)} sensor connecting...`);
        }
      }

      // Connect WebSockets for all enabled sensors
      function connectWebSockets() {
        if (!isSessionActive) return;
        
        console.log('Connecting WebSockets for enabled sensors...');
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const baseUrl = `${protocol}//${window.location.host}`;
        
        if (enabledSensors.pose) {
          updateConnectionStatus('pose', 'connecting');
          // Connect pose WebSocket
          poseWs = new WebSocket(`${baseUrl}/pose`);
          poseWs.onopen = () => {
            console.log('Pose WebSocket connected');
            updateConnectionStatus('pose', 'connected');
          };
          poseWs.onerror = (error) => {
            console.error('Pose WebSocket error:', error);
            updateConnectionStatus('pose', 'disconnected');
          };
          poseWs.onclose = () => {
            updateConnectionStatus('pose', 'disconnected');
            if (isSessionActive) {
              setTimeout(() => {
                if (enabledSensors.pose && isSessionActive) {
                  connectPoseWebSocket();
                }
              }, 1000);
            }
          };
        }

        if (enabledSensors.camera) {
          updateConnectionStatus('camera', 'connecting');
          // Connect camera WebSocket
          cameraWs = new WebSocket(`${baseUrl}/camera`);
          window.cameraWs = cameraWs;
          
          cameraWs.onopen = () => {
            console.log('Camera WebSocket connected');
            updateConnectionStatus('camera', 'connected');
            if (!cameraInterval && isSessionActive) {
              startCameraSending();
            }
          };
          cameraWs.onerror = (error) => {
            console.error('Camera WebSocket error:', error);
            updateConnectionStatus('camera', 'disconnected');
          };
          cameraWs.onclose = () => {
            updateConnectionStatus('camera', 'disconnected');
            window.cameraWs = null;
            if (isSessionActive) {
              setTimeout(() => {
                if (enabledSensors.camera && isSessionActive) {
                  connectCameraWebSocket();
                }
              }, 1000);
            }
          };
        }

        if (enabledSensors.microphone) {
          updateConnectionStatus('microphone', 'connecting');
          microphoneWs = new WebSocket(`${baseUrl}/microphone`);
          microphoneWs.onopen = () => {
            console.log('Microphone WebSocket connected');
            updateConnectionStatus('microphone', 'connected');
            speechRecognitionManager.startSpeechRecognition(microphoneWs, isSessionActive);
          };
          microphoneWs.onerror = (error) => {
            console.error('Microphone WebSocket error:', error);
            updateConnectionStatus('microphone', 'disconnected');
          };
          microphoneWs.onclose = () => {
            updateConnectionStatus('microphone', 'disconnected');
            if (isSessionActive) {
              setTimeout(() => {
                if (enabledSensors.microphone && isSessionActive) {
                  connectMicrophoneWebSocket();
                }
              }, 1000);
            }
          };
          
          // Add message handler for transcription results
          microphoneWs.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              if (data.transcription) {
                addTranscriptionEntry(data.transcription);
              }
            } catch (error) {
              console.error('Error parsing microphone response:', error);
            }
          };
        }

        // Connect Audio WebSocket (output)
        if (enabledSensors.audio) {
          updateConnectionStatus('audio', 'connecting');
          
          if (!window.tts) {
            window.tts = new TextToSpeech();
          }
          
          window.tts.connectWebSocket().then(() => {
            console.log('Audio WebSocket connected successfully');
            updateConnectionStatus('audio', 'connected');
            ttsWs = window.tts.ws;
          }).catch(err => {
            console.error('Failed to connect Audio WebSocket:', err);
            updateConnectionStatus('audio', 'disconnected');
          });
          
          // Connect WAV audio WebSocket if enabled
          fetch('/api/config')
            .then(response => response.json())
            .then(config => {
              if (config.audio && config.audio.mode === 'wav' && config.audio.enabled) {
                console.log('WAV audio mode detected, activating WAV WebSocket...');
                if (window.audioPlayer && typeof window.audioPlayer.connectWebSocket === 'function') {
                  console.log('WAV audio player connected and activated');
                } else {
                  console.log('WAV audio player not available or not fully initialized');
                }
              }
            })
            .catch(err => console.error('Failed to check WAV audio config:', err));
        }
      }

      function startCameraSending() {
        if (cameraSendingActive) return;
        
        cameraSendingActive = true;
        cameraInterval = setInterval(() => {
          if (cameraWs && cameraWs.readyState === WebSocket.OPEN) {
            const cameraFrame = cameraManager.getLastFrame();
            if (cameraFrame) {
              cameraWs.send(JSON.stringify({
                timestamp: Date.now(),
                camera: cameraFrame,
                width: cameraManager.fixedWidth || 480,
                height: cameraManager.fixedHeight || 640
              }));
            }
          }
        }, 30);
      }

      function stopCameraSending() {
        cameraSendingActive = false;
        if (cameraInterval) {
          clearInterval(cameraInterval);
          cameraInterval = null;
        }
      }

      async function startSession() {
        try {
          if (enabledSensors.pose) {
            // Start AR session only if position tracking is enabled
            xrSession = await navigator.xr.requestSession('immersive-ar', {
              requiredFeatures: ['local'],
              optionalFeatures: ['dom-overlay'],
              domOverlay: { root: document.body },
              environmentBlendMode: 'opaque'
            });
            xrSession.addEventListener('end', onSessionEnded);

            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl', { xrCompatible: true });
            await xrSession.updateRenderState({
              baseLayer: new XRWebGLLayer(xrSession, gl)
            });

            xrRefSpace = await xrSession.requestReferenceSpace('local');
            xrSession.requestAnimationFrame(onXRFrame);
          }

          isSessionActive = true;
          xrButton.textContent = 'Stop';
          
          // Connect WebSockets first
          connectWebSockets();
          
          if (enabledSensors.camera) {
            cameraManager.startCamera(cameraWs, isSessionActive);
          }

          document.body.classList.add('session-active');

        } catch (e) {
          console.error('Failed to start session:', e);
          onSessionEnded();  // Clean up if start fails
        }
      }

      // When the session ends, reset button and display
      function onSessionEnded() {
        if (!isSessionActive) return;  // Prevent multiple calls
        
        // Reset all connection statuses
        ['pose', 'camera', 'microphone', 'audio'].forEach(type => {
          updateConnectionStatus(type, '');
        });
        
        isSessionActive = false;
        document.body.classList.remove('session-active');
        
        // Clean up WebSockets
        [poseWs, cameraWs, microphoneWs].forEach(ws => {
          if (ws) {
            ws.close();
          }
        });
        poseWs = cameraWs = microphoneWs = null;

        // Clean up managers
        cameraManager.stopCamera();
        speechRecognitionManager.stopSpeechRecognition();
        stopCameraSending();
        
        // Properly disconnect Audio
        if (window.tts) {
          window.tts.disconnectWebSocket();
        }
        
        // Disconnect WAV audio player if it exists
        if (window.audioPlayer && typeof window.audioPlayer.disconnectWebSocket === 'function') {
          window.audioPlayer.disconnectWebSocket();
          window.audioPlayer.setSessionActive(false);
          console.log('WAV audio player disconnected');
        }
        
        // Reset XR session
        if (xrSession) {
          xrSession = null;
          xrRefSpace = null;
        }

        // Update UI
        xrButton.textContent = 'Start';
        poseDiv.textContent = 'Session ended.';
      }

      // Send pose data when available
      function onXRFrame(time, frame) {
        xrSession.requestAnimationFrame(onXRFrame);
        const pose = frame.getViewerPose(xrRefSpace);
        if (pose && enabledSensors.pose) {
          const pos = pose.transform.position;
          const o = pose.transform.orientation;
          const text = `Position: ${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)}
            Orientation: ${o.x.toFixed(3)}, ${o.y.toFixed(3)}, ${o.z.toFixed(3)}, ${o.w.toFixed(3)}`;
          // Print on mobile screen
          poseDiv.textContent = text;
          
          // Send pose data via dedicated WebSocket
          if (poseWs && poseWs.readyState === WebSocket.OPEN) {
            const poseData = {
              timestamp: Date.now(),
              pose: {
                position: { x: pos.x, y: pos.y, z: pos.z },
                orientation: { x: o.x, y: o.y, z: o.z, w: o.w }
              }
            };
            poseWs.send(JSON.stringify(poseData));
          }
        } else {
          poseDiv.textContent = 'No pose available.';
        }
      }

      // Function to add transcription entries to the log
      function addTranscriptionEntry(text) {
        const transcriptionLog = document.getElementById('transcription-log');
        if (!transcriptionLog) return;
        
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        
        const timestamp = document.createElement('span');
        timestamp.className = 'timestamp';
        timestamp.textContent = new Date().toLocaleTimeString();
        
        const content = document.createElement('span');
        content.textContent = text;
        
        entry.appendChild(timestamp);
        entry.appendChild(content);
        transcriptionLog.appendChild(entry);
        
        // Auto-scroll to the latest entry
        transcriptionLog.scrollTop = transcriptionLog.scrollHeight;
        
        // Limit the number of entries
        while (transcriptionLog.children.length > 50) {
          transcriptionLog.removeChild(transcriptionLog.firstChild);
        }
      }
      
      // Helper functions for reconnecting WebSockets
      function connectPoseWebSocket() {
        if (!isSessionActive) return;
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const baseUrl = `${protocol}//${window.location.host}`;
        
        poseWs = new WebSocket(`${baseUrl}/pose`);
        poseWs.onopen = () => {
          console.log('Pose WebSocket reconnected');
          updateConnectionStatus('pose', 'connected');
        };
        poseWs.onerror = (error) => {
          console.error('Pose WebSocket error:', error);
          updateConnectionStatus('pose', 'disconnected');
        };
        poseWs.onclose = () => {
          updateConnectionStatus('pose', 'disconnected');
          if (isSessionActive) {
            setTimeout(() => {
              if (enabledSensors.pose && isSessionActive) {
                connectPoseWebSocket();
              }
            }, 1000);
          }
        };
      }
      
      function connectCameraWebSocket() {
        if (!isSessionActive) return;
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const baseUrl = `${protocol}//${window.location.host}`;
        
        cameraWs = new WebSocket(`${baseUrl}/camera`);
        window.cameraWs = cameraWs;
        
        cameraWs.onopen = () => {
          updateConnectionStatus('camera', 'connected');
          if (!cameraInterval && isSessionActive) {
            startCameraSending();
          }
        };
        cameraWs.onerror = (error) => {
          updateConnectionStatus('camera', 'disconnected');
        };
        cameraWs.onclose = () => {
          updateConnectionStatus('camera', 'disconnected');
          window.cameraWs = null;
          if (isSessionActive) {
            setTimeout(() => {
              if (enabledSensors.camera && isSessionActive) {
                connectCameraWebSocket();
              }
            }, 1000);
          }
        };
      }
      
      function connectMicrophoneWebSocket() {
        if (!isSessionActive) return;
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const baseUrl = `${protocol}//${window.location.host}`;
        
        microphoneWs = new WebSocket(`${baseUrl}/microphone`);
        microphoneWs.onopen = () => {
          console.log('Microphone WebSocket reconnected');
          updateConnectionStatus('microphone', 'connected');
          speechRecognitionManager.startSpeechRecognition(microphoneWs, isSessionActive);
        };
        microphoneWs.onerror = (error) => {
          console.error('Microphone WebSocket error:', error);
          updateConnectionStatus('microphone', 'disconnected');
        };
        microphoneWs.onclose = () => {
          updateConnectionStatus('microphone', 'disconnected');
          if (isSessionActive) {
            setTimeout(() => {
              if (enabledSensors.microphone && isSessionActive) {
                connectMicrophoneWebSocket();
              }
            }, 1000);
          }
        };
        
        microphoneWs.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.transcription) {
              addTranscriptionEntry(data.transcription);
            }
          } catch (error) {
            console.error('Error parsing microphone response:', error);
          }
        };
      }
    </script>
  </body>
</html>